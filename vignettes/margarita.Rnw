%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Using margarita with texmex}
\documentclass[a4paper]{article}
\usepackage[british]{babel}
\usepackage{fancyhdr}
\pagestyle{fancy}
\rfoot{\thepage}
\begin{document}
\title{margarita: making texmex more digestible}
\author{Harry Southworth}
\maketitle%\thispagestyle{empty}

\section{Introduction}
This document illustrates some usage of the margarita
package for R. The purpose of the package is to provide
{\tt ggplot} replacement functions for several of
texmex's {\tt plot} functions, to enable simpler
robust regression modelling, and to enable much easier
prediction of return levels and threshold exceedance
probabilities.

The functionality or margarita is illustrated by
reanalysing the liver data that can be found in the
texmex package. We begin by loading the package and
producing the shiftplots.

<<width, echo=FALSE>>=
options(width=60)
@

<<shiftplots, echo=TRUE, fig.cap="Shiftplots of the liver data.">>=
set.seed(20130516)
library(margarita)
library(xtable)

shiftplot(liver, aes(ALT.B, ALT.M), by=~dose, xlab="Baseline ALT (U/L)",
          ylab="Maximum ALT (U/L)")
@

\section{Robust regression}
Robust regression can be performed using the {\tt lmr}
(linear model robust) function. This function is a
wrapper to {\tt rlm} in the MASS package, setting the
method to MM and efficiency to 85\%. It also computes
the coefficient covariance and attaches it to the
returned object. A ggplot function for diagnostics is
provided.

<<lmr, echo=TRUE>>=
liver$ndose <- as.numeric(liver$dose)
mm <- lmr(log(ALT.M) ~ log(ALT.B) + ndose, data=liver)
ggplot(mm)

liver$r <- resid(mm)
boxplot(mm, by="dose")
@

\section{Extreme value modelling}
We now move on to fit generalized Pareto distributions to the
residuals from the robust regression. First we examine some threshold
selection plots, then fit the model by maximum likelihood and look
at diagnostic plots, then refit by MCMC and look at diagnostic plots
of the Markov chains.
<<extreme, echo=TRUE>>=
# Do threshold selection plots
ggplot(gpdThresh(liver$r))

# Fit GPD model by penalized ML
mlmod <- evm(r, data=liver, qu=.7, xi=~ndose, penalty="none")
ggplot(mlmod)

# Refit using MCMC
gmod <- evm(r, data=liver, qu=.7, xi=~ndose,
            method="sim", verbose=FALSE)
ggplot(gmod)
@

\section{\tt margarita}
Before simulating return levels and probabilities of
threshold exceedance, we first create a new object that
contains the robust regression model, the extreme value
model, and other information to allow the simulations to
be performed. The function we use is {\tt margarita}.
<<margarita, echo=TRUE>>=
nd <- data.frame(ndose=1:4)
mods <- margarita(mm, gmod, newdata=nd,
                  trans=log, invtrans=exp,
                  baseline="ALT.B")
@

\section{Return levels}
Return levels for clinical trial data can be simulated
using the {\tt simulate} function with {\tt type=`rl'}
(the default). Note that only one return level can be
simulated at a time (e.g. the 100-patient return level),
so if you want, say, the 100- and 1000-patient return
levels, you'll need to call {\tt simulate} twice,
once with {\tt M=100} and once with {\tt M=1000}.

The first step before simulation is to create a new
object of class `margarita' that contains the robust
linear model and the evmSim model. The {\tt simulate}
functions infer from the number of draws from the
posterior distributions contained in the extreme
value model how many cases to simulate.

To deal with all kinds of trial designs, the
{\tt simulate} function requires a {\tt newdata}
argument. The rows of {\tt newdata} should be
unique and it should {\emph not} contain the baseline
data. Baseline data are simulated internally by
resampling from the data attached to the linear
model.

<<rl, echo=TRUE>>=
rl1000 <- simulate(mods, type="rl", M=1000)

s <- summary(rl1000)
suln <- s/36
sFold <- summary(rl1000, scale="proportional")
sDiff <- summary(rl1000, scale="difference")

rownames(s) <- paste("Dose", LETTERS[1:4])
rownames(sFold) <- rownames(sDiff) <- rownames(suln) <- rownames(s)
gs <- ggplot(s, xlab="U/L")
gsuln <- ggplot(suln, xlab="Multiples of ULN")
gsFold <- ggplot(sFold, xlab="Fold-change from baseline")
gsDiff <- ggplot(sDiff, xlab="Change in U/L from baseline")
grid.arrange(gs, gsuln, gsFold, gsDiff)
@

Notice that for return levels, because of the way they are
calculated, it is straightforward to change the scale
after the calculations have been done. It is achieved by
providing optional arguments to {\tt summary} or by
manipulating the object returned by {\tt summary} direclty.

\section{Threshold exceedance probabilities}
When simulating threshold exceedance probabilities, the
scale of the predicted values needs to be specifed in the
call to {\tt simulate} rather than {\tt summary}.

First we find probabilities of threshold exceedance on the
scale of the raw data (i.e. multiples of ULN), then in terms
of multiples of baseline.

<<prob, echo=TRUE>>=
pULNs <- simulate(mods, type="prob",
                  M=36*c(1, 3, 10, 20),
                  Mlabels=c("P(ALT > ULN)", "P(ALT > 3xULN)", "P(ALT > 10xULN)", "P(ALT > 20xULN)"))
ps <- summary(pULNs)

# Manually set the treatment group names
names(ps) <- LETTERS[1:4]
ggplot(ps, ncol=1)

# Simulate fold-changes from baseline
pBase <- simulate(mods, type="prob", M=c(2, 5, 10, 20),
                  Mlabels=c("2-fold", "5-fold", "10-fold", "20-fold"),
                  scale="proportional")
pbs <- summary(pBase)

# Manually change treatment group names
names(pbs) <- LETTERS[1:4]
ggplot(pbs, ncol=1, xlab="")
@


\end{document}
